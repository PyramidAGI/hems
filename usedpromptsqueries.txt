make a python program that uses the following sqlite. this is a HEMS for efficiently controlling energy usage in a home. 
insert into rules (ruletype,importance,description,value,unit) values ('grid:connection',0,'max household energy supply',17,'kW');
insert into rules (ruletype,importance,description,value,unit) values ('production:solar:min',2,'min solar production for smart stuff',2,'kW');
insert into rules (ruletype,importance,description,value,unit) values ('state:battery:min',2,'min state of charge',1,'kWh');
insert into rules (ruletype,importance,description,value,unit) values ('state:battery:max',2,'max state of charge',18,'kWh');
insert into rules (ruletype,importance,description,value,unit) values ('consumption:battery:max',2,'max power',5,'kW');
insert into rules (ruletype,importance,description,value,unit) values ('consumption:heatpump:max',1,'max power consumption',7,'kW');
insert into rules (ruletype,importance,description,value,unit) values ('consumption:heatpump:min',1,'min steady state power consumption',7,'kW');
insert into rules (ruletype,importance,description,value,unit) values ('consumption:charger:max',2,'max power consumption',11,'kW');
insert into rules (ruletype,importance,description,value,unit) values ('consumption:charger:min',2,'min power consumption',7,'kW');
insert into rules (ruletype,importance,description,value,unit) values ('state:house:min',1,'min temp at home',15,'C');
insert into rules (ruletype,importance,description,value,unit) values ('state:house:max',1,'min temp at home',20,'C');
insert into rules (ruletype,importance,description,value,unit) values ('people:presense:min',2,'movement at home',5,'%');

CREATE TABLE rules (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    ruletype VARCHAR(25) NOT NULL,
    importance integer NOT NULL,
    description VARCHAR(255) NOT NULL,
    value INTEGER NOT NULL,
    unit VARCHAR(10) NOT NULL,
    startdate VARCHAR(25),
    enddate VARCHAR(25),
    starttime varchar(25),
    endtime varchar(25),
    status INTEGER,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE metarules (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    rulename VARCHAR(25) NOT NULL,
    ruletype VARCHAR(25) NOT NULL,
    importance integer NOT NULL,
    description VARCHAR(255) NOT NULL,
    unit VARCHAR(10) NOT NULL,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP
);


insert into metarules (rulename,ruletype,importance,description,unit) values ('sufficient power','grid',0,'Verify rest power available','kW');
insert into metarules (rulename,ruletype,importance,description,unit) values ('charge battery 1','battery',0,'Charge battery between min and max energy','kWh');
insert into metarules (rulename,ruletype,importance,description,unit) values ('charge battery 2','battery',0,'Battery between min and max power','kW');
insert into metarules (rulename,ruletype,importance,description,unit) values ('can charge battery','grid|battery',0,'Safe power','kW');

=====================
=====================
explain the sqlite view that joins decisions. i don't understand this?
=====================
yes implement both views
=====================

don't add the third view, but make one single program that includes the first two views
=====================
show the column names when displaying the views
=====================
insert statements run on : 15-10-2025:
insert into rules (ruletype,importance,description,value,unit) values ('grid:connection:max',0,'max household energy supply',17,'kW');
insert into rules (ruletype,importance,description,value,unit) values ('production:solar:max',0,'max solar production',6,'kW');
insert into rules (ruletype,importance,description,value,unit) values ('production:battery:max',0,'max battery production',5,'kW');
insert into rules (ruletype,importance,description,value,unit) values ('consumption:battery:max',0,'max power',8,'kW');
insert into rules (ruletype,importance,description,value,unit) values ('consumption:heatpump:max',0,'max power consumption',7,'kW');
insert into rules (ruletype,importance,description,value,unit) values ('consumption:heatpump:min',0,'min steady state power consumption',2,'kW');
insert into rules (ruletype,importance,description,value,unit) values ('consumption:charger:max',0,'max power consumption',11,'kW');
insert into rules (ruletype,importance,description,value,unit) values ('consumption:charger:min',0,'min power consumption',6,'kW');
insert into rules (ruletype,importance,description,value,unit) values ('state:battery:min',0,'min state of charge',1,'kWh');
insert into rules (ruletype,importance,description,value,unit) values ('state:battery:max',0,'max state of charge',18,'kWh');
insert into rules (ruletype,importance,description,value,unit) values ('state:car:min',0,'min state of charge',10,'kWh');
insert into rules (ruletype,importance,description,value,unit) values ('state:car:max',0,'max state of charge',90,'kWh');
insert into rules (ruletype,importance,description,value,unit) values ('state:house:min',0,'min temp at home',15,'C');
insert into rules (ruletype,importance,description,value,unit) values ('state:house:max',0,'min temp at home',20,'C');
insert into rules (ruletype,importance,description,value,unit) values ('people:presense:min',0,'movement at home',5,'%');

=====================
insert into metarules (rulename,ruletype,importance,description,unit) values ('Safe power','grid',0,'Verify grid connection is not overloaded','kW');
insert into metarules (rulename,ruletype,importance,description,unit) values ('charge battery 1','battery',3,'Charge battery between min and max energy','kWh');
insert into metarules (rulename,ruletype,importance,description,unit) values ('can charge battery','grid && battery',3,'Verify power available','kW');
insert into metarules (rulename,ruletype,importance,description,unit) values ('charge car 1','charger',2,'Charge car between min and max energy','kWh');
insert into metarules (rulename,ruletype,importance,description,unit) values ('can charge car','grid && charger',2,'Verify power available','kW');
insert into metarules (rulename,ruletype,importance,description,unit) values ('home temperature','home',1,'Maintain temperature in right range','C');
insert into metarules (rulename,ruletype,importance,description,unit) values ('can heat home','grid && heatpump',1,'Signal heatpump that the house must be heated','C && kW');
insert into metarules (rulename,ruletype,importance,description,unit) values ('optimize self consumption','grid && battery',0,'Try to balance production and consumption','kW');

=======================
Summary of Changes
1. Rule-Based Architecture
Replaced the monolithic decide() function with a collection of specialized rule evaluators
Each evaluator handles specific units and constraints (kW, kWh, °C, etc.)
2. Unit-Specific Evaluators
PowerLimitEvaluator: Enforces maximum power constraints (kW limits)
EnergyConstraintEvaluator: Manages battery energy limits (kWh constraints)
TemperatureControlEvaluator: Handles heating/cooling logic (°C evaluation)
SolarOptimizationEvaluator: Optimizes solar energy utilization
ChargerPriorityEvaluator: Manages EV charging allocation
GridBalanceEvaluator: Enforces grid connection limits
3. Priority-Based Execution
Rules execute in order of priority (1-6)
Each rule can modify the setpoints based on its specific domain
Later rules can override earlier decisions if needed
4. Debugging & Traceability
Added --show-rules-eval CLI option to see how each rule affects the decision
decide_with_trace() method shows the step-by-step evaluation process
Each rule change is logged with before/after values
5. Example Usage
6. Benefits of This Approach
Modularity: Each rule is self-contained and testable
Extensibility: Easy to add new rules or modify existing ones
Unit Safety: Each evaluator knows how to handle its specific units (kW vs kWh vs °C)
Transparency: Clear trace of which rules made which decisions
Maintainability: Logic is separated by concern/domain
The system now operates as a true rule-based engine where each rule evaluator can inspect the current state and make adjustments according to its specific domain expertise!